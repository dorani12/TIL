### 알고리즘
알고리즘 14일차  
SWEA 문제풀이2  
***
- 1220: 마그네틱  
  ```python
  '''
  [입력] 각 테스트 케이스의 첫 번째 줄에는 정사각형 테이블의 한 변의 길이 = 항상 100
  100 x 100크기의 테이블의 초기 모습 => 1은 N극, 2는 S극| 테이블의 윗부분에 N극, 아래부분에 S극

  [출력]  자성체들이 서로 충돌하여 테이블 위에 남아있는 교착 상태의 개수를 출력
  #############################################################
  교착상태가 발생하는 경우는 N극의 자성체가 S극을 만나러 아래로 이동하며, 중간에 S극을 만나서 교착되는 경우 뿐
  '''

  N_pole = 1                      # 1은 N극 성질을 가지는 자성체를 2는 S극 성질을 가지는 자성체
  S_pole = 2                      # 테이블의 윗부분에 N극이 아래부분에 S극이 위치

  T = 10
  for tc in range(1, T+1):
      N = int(input())
      arr = [list(map(int, input().split())) for _ in range(N)]

      cnt = 0                     # 교착상태 수
      for j in range(100):        # 열 우선
          np = 0                  # 아래로 향하는 N극이 있는지 표시
          for i in range(100):
              if arr[i][j] == N_pole:
                  np = 1
              elif arr[i][j] == S_pole and np == 1: # N극과 S극이 만나는 경우 교착
                  cnt += 1
                  np = 0
      print(f'#{tc} {cnt}')
  ```

---
- 3449: 퍼펙트 셔플
  ```python
  '''
  카드 덱을 정확히 절반으로 나누고 나눈 것들에서 교대로 카드를 뽑아 새로운 덱을 만드는 것을 의미
  N개의 카드가 있는 덱이 주어질 때 이를 퍼펙트 셔플하면 어떤 순서가 되는지 출력(N이 홀수이면, 교대로 놓을 때 먼저 놓는 쪽에 한 장이 더 들어가게)
  [입력] 각 테스트 케이스의 첫 번째 줄에는 자연수 N(1 ≤ N ≤ 1,000) | 두 번째 줄에는 덱에 카드가 놓인 순서대로 N개의 카드 이름 = 알파벳 대문자와 ‘-’만으로 이루어져 있으며, 길이는 80이하

  [출력] 각 테스트 케이스마다 주어진 덱을 퍼펙트 셔플한 결과를 한 줄에 카드 이름을 공백으로 구분하여 출력
  #############################################################

  '''

  T = int(input())
  for tc in range(1, T+1):
      N = int(input())
      card = input().split()
      deck = [0]*N

      d = (N+1)//2        # 아래 카드 시작, N//2+N%2
      i1 = 0              # 시작 값: 0
      i2 = d              # 시작: 중간 idx
      i3 = 0              # 새로 만들 덱의 인덱스
      while i3 < N:
          if i1 < d:      # 0부터 절반
              deck[i3] = card[i1]
              i1 += 1
              i3 += 1
          if i2 < N:      # 절반 이후의 값
              deck[i3] = card[i2]
              i2 += 1
              i3 += 1

      print(f'#{tc}', *deck)
  ```
---
- 10580: 전봇대
  ```python
  '''
  [입력] 첫 번째 줄에 주어지는 전선의 개수 N이 주어진다 (1 ≤ N ≤1000).
  이후 N개의 줄에 두 양의 정수 Ai, Bi 가 주어진다. (1 ≤ Ai, Bi ≤ 10000)이는 i번째 전선이, 첫번째 전봇대의 Ai cm 고도에 걸려 있고, 두 번째 전봇대의 Bi cm 고도에 걸려 있음
  모든 Ai는 서로 다르고, 모든 Bi 도 서로 다르다. (두 전선의 끝점이 같은 경우가 없기 때문이다.) 세 전선이 한 점에서 만나지 않게 입력이 주어진다.

  [출력] 전봇대에는 총 몇 개의 교차점?
  #############################################################
  이전에 연결된 전선 중에서, 나보다 높은 곳에 연결된 줄이 몇 개인지 카운트
  '''

  T = int(input())
  for tc in range(1, T+1):
      N = int(input())
      ab = [list(map(int, input().split())) for _ in range(N)]

      ab.sort()                               # 오름차순 정렬
      cnt = 0                                 # 교차점 개수
      for i in range(1, N):
          for j in range(i):                  # 내가 연결되기 전에, 연결된 전선들 상태 확인
              if ab[j][1] > ab[i][1]:         # a가 더 아래있지만(오름차순 정렬이여서 i < j) b가 더 높으면(index 1 값) 교차점
                  cnt += 1

      print(f'#{tc}', {cnt})
  ```
---
- 20739: 고대 유적 2
  ```python
  '''
  사진의 해상도는 NxM, 구조물이 있는 곳은 1, 빈 땅은 0 | 교차하거나 만나는 것처럼 보이는 구조물은 서로 다른 깊이에 묻힌 것이므로 직선인 구조만 고려
  구조물의 최소 크기는 1x2
  [입력] 첫 줄에 사진 데이터의 개수, 다음 줄부터 사진 데이터 별로 첫 줄에 N과 M, 이후 N개의 줄에 M개씩의 데이터

  [출력] 각 구역 별로 가장 긴 구조물의 길이?
  #############################################################
  '''
  T = int(input())
  for tc in range(1, T+1):
      N, M = map(int, input().split())
      arr = [list(map(int, input().split())) for _ in range(N)]
      max_v = 0                                   # 가장 긴 구조물 길이
      
      # i행에서 가로 구조물 길이 확인
      for i in range(N):                          
          cnt = 0                                 # 구조물 길이_행별로 순회 할 때마다 초기화
          for j in range(M):
              if arr[i][j]:                       # 구조물이면
                  cnt += 1                        # 길이 1m증가
                  if max_v < cnt:                 # 가로 구조물의 최대 길이 찾기
                      max_v = cnt
                  # max_v = max(max_v, cnt)
              else:
                  cnt = 0
      
      # j열에서 세로 구조물 길이 확인
      for j in range(M):                          
          cnt = 0 
          for i in range(N):
              if arr[i][j]:                       # 구조물인 경우
                  cnt += 1
                  if max_v < cnt:                 # 가로 구조물의 최대 길이 찾기
                      max_v = cnt
              else:
                  cnt = 0
      
      if max_v == 1:                              # 노이즈인 경우
          max_v = 0
      print(f'#{tc} {max_v}')
  ```
***