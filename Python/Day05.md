## 파이썬 Data Structure에 따른 Method
data structure와 method_str, list

---
#### 데이터 구조 Data Structure  
- 여러 데이터를 효과적으로 사용, 관리하기 위한 구조 (str, list, dict 등)

### Method 메서드  
- 객체에 속한 함수  
- 객체의 상태를 조작하거나 동작을 수행  
- 메서드는 클래스(class) 내부에 정의되는 함수_자료형의 형태에 따라 메소드의 종류   
  
  =  수행할 수 있는 연산의 종류가 다름   
  
  -내가 지정한 클래스 내에서 method를 만들 수 있음   
  ex) 
  ```python
  numbers = [1, 2, 3]  
  numbers.append(4) #[1, 2, 3, 4]  
  ```
  같이 배열에 값을 추가하는 함수, capitalize()같이 대문자로 변환 등 여러 역할을 수행함

### 시퀀스 메서드  
순서가 있는 자료형에서의 method  

*내용 복습*
##### Sequence Types
- 여러 개의 값들을 <span style='color:crimson;'>순서대로 나열</span>하여 저장하는 자료형
(str, list, tuple, range)

###### Sequence Type 특징
1. 순서(Sequence)
    - 값들이 순서대로 저장 (정렬 X)
2. 인덱싱(Indexing)
    - 각 값에 고유한 인덱스(번호)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정할 수 있음
3. 슬라이싱(Slicing)
    - 인덱스 범위를 조절해 부분적인 값을 추출할 수 있음
4. 길이(Length)
    - len() 함수를 사용하여 저장된 값의 개수(길이)를 구할 수 있음
5. 반복(Iteration)
    - 반목문을 사용하여 저장된 값들을 반복적으로 처리할 수 있음
### 1. str 문자열
#### 문자열 조회/탐색 및 검증 메서드  
|        메서드      	|                                         설명                                        	|
|:------------------:	|:-----------------------------------------------------------------------------------:	|
|      s.find(x)     	|     x의   첫 번째 위치를 반환(없으면, -1 반환)                                  	|
|      s.index(x)    	|     x의   첫 번째 위치를 반환(없으면, 오류 발생)                                  	|
|     s.isupper()    	|     대문자 여부                                                                     	|
|     s.islower()    	|     소문자 여부                                                                   	|
|     s.isalpha()    	|     알파벳 문자 여부      *단순 알파벳이 아닌 유니코드 상 Letter (한국어도 포함)    	|

####
string의 경우 불변의 자료형
따라서 replace, strip과 같은 메소드를 사용한다고 하더라도 원본의 문자열을 변경하는게 아닌 조작을 거친 새로운 문자열을 반환하게 됨
`.replace(old, new[,count])` 에서 []안에 표기 된 값은 생략 가능

메소드를 통해 변경한 값은 반환 값이 있기 때문에, method를 연결해서 ㅁ.ㅁㅁ().ㅁㅁ()와 같이 연결해서도 사용가능함

### 2. 리스트

#### 리스트 값 추가 및 삭제 메서드
|          메서드         	|                                                   설명                                                  	|
|:-----------------------:	|:-------------------------------------------------------------------------------------------------------:	|
|        L.append(x)      	|     리스트   마지막에 항목 x를   추가                                                                   	|
|        L.extend(m)      	|     Iterable m의   모든 항목들을 리스트 끝에 추가 (+=과   같은 기능)                                    	|
|     L.insert(i,   x)    	|     리스트   인덱스 i에 항목 x를 삽입                                                                   	|
|        L.remove(x)      	|     리스트   가장 왼쪽에 있는 항목(첫 번째)   x를   제거     항목이 존재하지 않을 경우,   ValueError    	|
|          L.pop()        	|     리스트   가장 오른쪽에 있는 항목(마지막)을   반환 후 제거                                           	|
|         L.pop(i)        	|     리스트의 인덱스 i에   있는 항목을 반환 후 제거                                                      	|
|         L.clear()       	|     리스트의 모든 항목 삭제                                                                             	|

```python
queue = [1, 2, 3, 4]

print(queue.pop(0))  # 1
print(len(queue))    # 3 원소 자체를 배열에서 꺼내오고, 해당하는 칸 없애버림

queue.remove(4)
print(len(queue))    # 2
print(queue)         # [2, 3]
```
#### 리스트 탐색 및 정렬 메서드
|               문법              	|                                   설명                                 	|
|:-------------------------------:	|:----------------------------------------------------------------------:	|
|     L.index(x)    	|     리스트에   있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환    	|
|            L.count(x)           	|     리스트에서 항목   x의 개수를 반환                                  	|
|            L.reverse()          	|     리스트의 순서를 역순으로 변경 (정렬 X)|
|             L.sort()            	|     리스트를 정렬 (매개변수   이용가능)                                	|
#### 할당 VS 복사
data가 변경가능한 자료형인 경우_리스트, 튜플 등
값을 복제하려고 새로운 변수에 할당하고, 값을 변경해주면 원래 변수도 값이 바뀌어버림.....

_값들을 복제해 주는게 아니라 
메모리 주소 값을 할당해주는 것이기 때문에 내가 할당게 변경되면 둘다 같은 값이 나옴
_변경가능? 불가능?!

#### 얕은 복사   
but)slicing [:]을 통해 복사해주면 얕은 복사를 통해 새로운 주소 값 할당됨_새로운 값만 변경 가능  
한계)중첩된 요소_리스트 안에 저장된 리스트?!는 같은 주소를 바라보게됨  

#### 깊은 복사  
```python
import copy   
a = [1, 2, 3] 
b= a.copy.deepcopy(a) #복사대상
```
- 내부에 중첩된 모든 객체까지 새로운 객체 주소를 참조하도록 함

### 참고
isdecimal() / isdigit() / isnumeric()
#### 문자열에 포함된 문자들의 유형을 판별하는 메서드
- `isdecimal()`
    - 문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 True
- `isdigit()`
    - isdecimal()과 비슷하지만, 유니코드 숫자도 인식 ('①’ 도 숫자로 인식)
- `isnumeric()`
    - isdigit()과 유사하지만, 몇 가지 추가적인 유니코드 문자들을 인식 <br>(분수, 지수, 루트 기호도 숫자로 인식)
